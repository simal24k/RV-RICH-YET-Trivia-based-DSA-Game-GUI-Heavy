1|2|What is an ADT?|A model of data+operations|A code library|A compiler feature|A sorting rule|0|Concept layer, not implementation.
2|3|Which operation requires pointer updates in a singly linked list?|Insertion at head|Traversal|Array indexing|Binary search|0|Pointers move.
3|3|Which pointer exists only in doubly linked lists?|prev|link|tail|jump|0|Backward reference.
4|2|Which linked list allows circular traversal?|Circular LL|SLL|DLL|Binary tree|0|Last node connects to first.
5|3|Which search works only on sorted data?|Binary search|Linear search|DFS|BFS|0|Mid-based selection.
6|3|Which search estimates position using interpolation?|Interpolation search|Binary search|Jump search|Hash lookup|0|Formula-based guess.
7|4|Which sorting algorithm is stable?|Insertion sort|Selection sort|Heap sort|Quick sort|0|Order preserved.
8|4|Which has worst-case O(n²)?|Bubble|Merge|Heap|Quick (randomized)|0|Naive comparisons.
9|5|Which sort uses partitioning?|Quick sort|Merge sort|Radix|Bucket|0|Divide around pivot.
10|5|Merge sort uses which strategy?|Divide and conquer|Greedy|DP|Backtracking|0|Recursive splitting.
11|3|Which sort is non-comparison based?|Radix|Heap|Merge|Shell|0|Digit buckets.
12|4|Which data structure uses LIFO?|Stack|Queue|Graph|Array|0|Last in, first out.
13|3|Which is used to simulate recursion?|Stack|Queue|Tree|Hash table|0|Call frames.
14|3|Backtracking algorithm explores?|All possible states|Only sorted nodes|Only BFS|Only DFS|0|State-space.
15|4|Which issue occurs in naive recursion?|Stack overflow|Heap overflow|Queue underflow|Graph cycle|0|Deep calls.
16|4|Which uses FIFO?|Queue|Stack|Tree|Hash table|0|First in, first out.
17|3|Which queue supports insertion at rear, removal at front?|Simple queue|Deque|Circular array|Priority queue|0|Basic FIFO.
18|4|Which queue gives highest-priority removal first?|Priority queue|Circular queue|Double queue|Simple queue|0|Depends on priority.
19|4|Heaps implement which ADT?|Priority queue|Deque|Stack|BST|0|Efficient priority ops.
20|4|Heap property ensures?|Parent dominates children|Children dominate parent|Sorted array|Graph acyclic|0|Min/max organization.
21|4|Heap sort complexity?|O(n log n)|O(n²)|O(log n)|O(n)|0|Heapify + n removals.
22|4|BST search best case?|O(log n)|O(1)|O(n)|O(n log n)|0|Balanced depth.
23|5|Worst case BST becomes?|Linked list|Heap|AVL|Trie|0|Skewed on sorted input.
24|4|A complete binary tree has?|Filled left to right|Perfect leaves|Unbalanced nodes|Random filling|0|Level-wise fill.
25|5|Height of perfect binary tree?|log2(n+1) - 1|n|n log n|sqrt(n)|0|Full levels.
26|5|AVL trees maintain?|Height balance|Color balance|Degree limit|Sibling order|0|Rotations fix height.
27|5|Single rotation fixes which imbalance?|LL|LR|RL|RR|0|Straight left heavy.
28|5|Double rotation fixes?|LR or RL|LL only|RR only|LL/RR both|0|Z-shaped.
29|5|2-3 trees enforce?|All leaves same depth|Binary branching|Max 4 children|Fixed key count|0|Perfect height balance.
30|5|A B-tree node can have?|Multiple keys|Only one key|Only two keys|Only leaves|0|Multiway.
31|4|Hashing converts key to?|Index|Pointer|Node|Label|0|Direct address.
32|4|Collision resolution by chaining uses?|Linked lists|Arrays only|Stacks|Recursion|0|Buckets store lists.
33|4|Linear probing issue?|Primary clustering|Secondary memory|Heap corruption|DFS failure|0|Runs form.
34|5|Quadratic probing avoids?|Primary clustering|Hashing|Search|Rehash|0|Better spread.
35|4|Rehashing occurs when?|Load factor high|Key error|Tree full|Index sorted|0|Resize table.
36|5|KMP uses?|Prefix table|Suffix array|Hash|Boyer skip|0|LPS array.
37|5|Boyer-Moore uses?|Bad-character rule|Heap|Tree|Radix buckets|0|Skip ahead.
38|5|Rabin-Karp uses?|Rolling hash|Prefix tree|Graph|Stack|0|Fast substring checks.
39|4|Graphs consist of?|Vertices + edges|Nodes only|Edges only|Heaps|0|Basic structure.
40|4|Adjacency list is efficient for?|Sparse graphs|Dense graphs|Complete graphs|Binary trees|0|Few edges.
41|4|DFS uses?|Stack|Queue|Heap|Hash|0|Implicit/explicit stack.
42|4|BFS uses?|Queue|Stack|Tree|Linked list|0|Level-order.
43|5|Topological sort applies to?|DAG|Cyclic graph|Tree|Complete graph|0|Order by dependency.
44|5|Minimum spanning tree algorithm?|Kruskal|KMP|Boyer|Hoare|0|Greedy edges.
45|5|Prim’s algorithm uses?|Priority queue|Deque|Stack|List only|0|Grow tree.
46|5|Shortest path in weighted graph?|Dijkstra|DFS|BFS|Quick|0|Non-negative weights.
47|5|BST insertion is?|Recursive/iterative|Always O(1)|Non-deterministic|Randomized|0|Compare + descend.
48|3|Linked list stack push occurs at?|Head|Tail|Middle|Random|0|Fast insertion.
49|3|Queue based on LL removes from?|Head|Tail|Middle|None|0|Front removal.
50|4|Circular queue avoids?|Wasted space|Clustering|Tree imbalance|Hash collision|0|Wrap-around.
51|5|Merge sort space?|O(n)|O(1)|O(log n)|O(n²)|0|Extra array.
52|5|Quick worst case occurs on?|Sorted input (bad pivot)|Random input|Reverse hash|AVL|0|Pivot skew.
53|4|Shell sort improves on?|Insertion sort|Merge|BST|Hashing|0|Gapped comparison.
54|5|Radix sort needs?|Digits/buckets|Tree|Heap|Graph|0|Base-wise.
55|4|Safe arrays prevent?|Out-of-bound access|Hash collision|Heap overflow|AVL imbalance|0|Bounds checking.
56|5|Rule of Three includes?|Destructor|Copy ctor|Copy assignment|All 3|3|Memory safety.
57|3|Pass-by-reference allows?|Modify caller variable|Copy only|No access|Deep clone|0|Alias effect.
58|4|Binary tree max nodes at level h?|2^h|h|h²|log h|0|Level doubling.
59|4|Full binary tree property?|0 or 2 children|1 child only|More than 2 children|Arbitrary|0|No single-child nodes.
60|4|Complete binary tree property?|Filled left→right|Right→left full|Skew only|Random|0|Strict filling.
61|4|Height of complete tree approx?|log n|n|n log n|1|0|Near balanced.
62|4|Traversal root-left-right?|Preorder|Inorder|Postorder|Level|0|Prefix visit.
63|4|Traversal left-root-right?|Inorder|Preorder|Postorder|Level|0|Sorted for BST.
64|4|Traversal left-right-root?|Postorder|Preorder|Inorder|Level|0|Suffix visit.
65|4|Level order uses?|Queue|Stack|Hash|Tree|0|Breadth-first.
66|5|Height of AVL guaranteed?|O(log n)|O(n)|O(1)|O(n log n)|0|Balanced.
67|5|Heap represented using?|Array|LL only|Tree pointer|Trie|0|Index math.
68|4|Parent index in heap array?|(i-1)/2|2i|2i+1|i+1|0|Integer division.
69|4|Left child index?|2i+1|i+1|i-1|log i|0|Formula.
70|4|Right child index?|2i+2|i+2|i/2|3*i|0|Offset by 2.
71|4|Ideal hash load factor?|< 0.75|0.99|2|0.1|0|Balanced.
72|5|Rehash time cost?|O(n)|O(1)|O(log n)|O(n log n)|0|Reinsert all.
73|4|DFS detects cycles in?|Directed graphs|Heaps|Trees|Arrays|0|Back edges.
74|4|BFS finds shortest path in?|Unweighted graph|Weighted graph|Hash|Heap|0|Levels.
75|5|Dijkstra fails with?|Negative edges|Positive edges|Zero weights|Unweighted graph|0|Needs Bellman-Ford.
76|4|Adjacency matrix memory heavy for?|Dense graphs|Sparse graphs|Binary trees|Stacks|0|n² space.
77|4|Backtracking used in?|N-Queens|Bubble sort|Hashing|Prim|0|State search.
78|5|Pruning reduces?|Search states|Edges|Hash keys|Tree height|0|Efficiency.
79|4|Call stack stores?|Activation records|Graph edges|Heap nodes|Queue indices|0|Function context.
80|5|Tail recursion optimized by?|Compiler|Heap|Graph|Assembler|0|Stack elimination.
81|3|Queue overflow when?|Full|Empty|Front null|Rear null|0|No space left.
82|3|Stack underflow when?|Pop empty|Push full|Mid removed|Allocated|0|Empty pop.
83|5|Balanced search tree ensures?|Bounded height|Zero height|Hashing|Matrix|0|Log time.
84|5|B-tree used in?|Databases|Stacks|Graphs|Queues|0|Disk-friendly.
85|4|Hash function goal?|Uniform distribution|Sorted keys|Tree structure|Binary layout|0|Even spread.
86|5|Universal hashing avoids?|Predictable collisions|Heap errors|DFS cycles|Tree skew|0|Randomness.
87|4|Trie used for?|Prefix search|Sorting|Pathfinding|Compression|0|String dictionary.
88|5|BST removal requires?|Successor/predecessor|Queue|Hash|Merge|0|Replace node.
89|4|Skewed BST height?|O(n)|O(1)|O(log n)|O(n log n)|0|Linked-list-like.
90|5|Quick pivot choice affects?|Performance|Correctness|Hashing|Graph edges|0|Partition balance.
91|5|MST requires?|Connected graph|Directed graph|Negative cycles|No edges|0|Spanning possible.
92|5|Kruskal needs?|Sorting edges|Prefix table|Hash|Bitmask|0|Greedy.
93|4|Disjoint set used in?|Kruskal|KMP|Radix|Bubble|0|Cycle detection.
94|5|Path compression makes DSU?|Almost constant time|O(n)|O(log n)|Slow|0|Flattens tree.
95|4|Binary search requires?|Sorted data|Linked list|Graph|Hash|0|Mid-based.
96|4|Worst case linear search?|O(n)|O(1)|O(log n)|O(n log n)|0|Scan all.
97|4|Interpolation search fails on?|Uneven data|Sorted data|Even data|Hash|0|Requires uniform distribution.
98|3|DLL insertion before node requires updating?|4 pointers|1 pointer|None|2 pointers|0|Prev/next of two nodes.
99|4|Circular LL traversal ends when?|Back at head|Null found|Tail reached|Level up|0|Loop detected.
100|4|Array queue suffers?|False full|Infinite memory|Duplicate keys|Skew|0|Needs circular solution.
101|5|AVL rotation count worst case?|O(1)|O(n)|O(log n)|O(n log n)|0|Constant.
102|5|AVL height diff allowed?|≤1|≤2|≤3|Unlimited|0|Strict.
103|4|Heap insertion uses?|Percolate up|Percolate down|Hash|Rotate|0|Bubble up.
104|4|Heap deletion removes?|Root|Leaf|Middle|Child|0|Top priority.
105|5|Chaining worst search?|O(n)|O(1)|O(log n)|O(n log n)|0|All in one bucket.
106|4|Open addressing stores keys?|In array|In LL|Outside table|Tree|0|Probing.
107|4|Probe sequence must be?|Deterministic|Random|Sorted|Graph-like|0|Searchable.
108|5|Double hashing reduces?|Clustering|Tree height|Stack depth|Sort time|0|Better distribution.
109|4|DFS stack depth worst?|O(n)|O(1)|O(log n)|O(n log n)|0|Deep path.
110|5|Topological sort impossible if?|Cycle exists|Sparse|Dense|Small|0|Cycle breaks order.
111|4|Graph with edges < vertices?|Sparse|Dense|Complete|Tree|0|Low density.
112|4|Complete graph edges?|n(n-1)/2|n|log n|n²|0|All pairs.
113|5|DAG stands for?|Directed Acyclic Graph|Dual Adjacent Graph|Deep Array Graph|Degree Access Graph|0|No cycles.
114|3|Dynamic structure?|LL|Array|Matrix|Static table|0|Can grow.
115|4|Leaf node has?|0 children|1 child|2 children|3 children|0|Terminal.
116|5|BST inorder gives?|Sorted sequence|Reverse|Random|Level-wise|0|Monotonic.
117|5|Hash table worst case becomes?|Linked list|Tree|Heap|Graph|0|Collisions chain.
118|4|Array stack needs?|Top pointer|Front|Rear|Middle|0|Index.
119|4|LL queue needs?|Front+rear|Top|Left|Prev|0|Track both ends.
120|3|Unbounded logically?|LL queue|Array queue|Static tree|Matrix|0|Memory-dependent.
121|5|Quick average complexity?|O(n log n)|O(n)|O(n²)|O(log n)|0|Random pivot.
122|5|Count sort requires?|Small key range|Strings|Huge ranges|Tree nodes|0|Range-indexed.
123|4|Cycle detection uses?|DFS|BFS|Hash|Stack|0|Back edges.
124|5|Bellman-Ford handles?|Negative weights|Only positive|Only zero|Trees|0|Relax edges.
125|4|STL stack uses?|Deque|Tree|Graph|Set|0|Backed by deque.
126|4|STL priority_queue uses?|Max heap|Min heap|Trie|List|0|Binary heap.
127|5|2-3 tree insertion triggers?|Node split|Rotation|Hash|Merge|0|Overflow fix.
128|5|B-tree height vs BST?|Lower|Higher|Equal|Random|0|Wide nodes reduce height.
129|5|Trie tradeoff?|High memory|Low memory|No nodes|Pure hashing|0|Node per char.
130|4|RK collision handled by?|Verification|Skip|Hashing|Probe|0|Re-check substring.
131|5|Boyer Moore best for?|Long patterns|Short patterns|Numbers|Single char|0|Large skips.
132|4|KMP prefix table stores?|Longest border|Suffix|Prefix only|Hash|0|Overlap lengths.
133|5|Prim vs Kruskal difference?|Graph representation sensitivity|Identical performance|Not greedy|Hash usage|0|Dense vs sparse.
134|4|Traversal must mark?|Visited|Weight|Parent|Hash|0|Prevent loops.
135|4|Stack frame stores?|Local vars|Graph edges|Heap nodes|Queue indices|0|Activation.
136|5|Backtracking relies on?|Undo operations|Hash table|Matrix|Heap|0|State revert.
137|4|Height of binary tree?|Longest path to leaf|Shortest path|Node count|Edge count only|0|Definition.
138|5|AVL insertion worst case needs?|1 or 2 rotations|Many rotations|Hash|Tree rebuild|0|Guaranteed small fix.
139|4|Circular queue full when?|(rear+1)%n==front|front==rear|rear==0|front==0|0|Full condition.
140|5|Bottom-up heapify cost?|O(n)|O(log n)|O(n log n)|O(1)|0|Linear build.
141|5|Negative cycles make shortest path?|Undefined|Finite|Always zero|Always positive|0|Cost decreases forever.
142|4|SLL access by index?|O(n)|O(1)|O(log n)|O(n log n)|0|Sequential.
143|4|Array indexing?|O(1)|O(n)|O(n²)|O(log n)|0|Random access.
144|5|Treap balances using?|Random priority|Height|Color|Hash|0|Probabilistic.
145|5|RB-tree property?|No path >2x shorter|All paths equal|Only 1 rotation allowed|No leaves|0|Black-height rule.
146|5|RB trees guarantee?|O(log n)|O(1)|O(n)|O(n log n)|0|Balanced.
147|4|Graph diameter?|Longest shortest path|Deepest DFS|Max height|Any cycle|0|Farthest distance.
148|5|Floyd-Warshall solves?|All-pairs shortest path|Single-source|Longest path|Hash|0|DP matrix.
149|4|Deque supports?|Insert both ends|Only rear|Only front|Random|0|Double-ended.
150|5|Branch and bound differs by?|Using cost bounds|DFS only|BFS only|Hash only|0|Prune by cost1|2|What is an ADT?|A model of data+operations|A code library|A compiler feature|A sorting rule|0|Concept layer, not implementation.
2|3|Which operation requires pointer updates in a singly linked list?|Insertion at head|Traversal|Array indexing|Binary search|0|Pointers move.
3|3|Which pointer exists only in doubly linked lists?|prev|link|tail|jump|0|Backward reference.
4|2|Which linked list allows circular traversal?|Circular LL|SLL|DLL|Binary tree|0|Last node connects to first.
5|3|Which search works only on sorted data?|Binary search|Linear search|DFS|BFS|0|Mid-based selection.
6|3|Which search estimates position using interpolation?|Interpolation search|Binary search|Jump search|Hash lookup|0|Formula-based guess.
7|4|Which sorting algorithm is stable?|Insertion sort|Selection sort|Heap sort|Quick sort|0|Order preserved.
8|4|Which has worst-case O(n²)?|Bubble|Merge|Heap|Quick (randomized)|0|Naive comparisons.
9|5|Which sort uses partitioning?|Quick sort|Merge sort|Radix|Bucket|0|Divide around pivot.
10|5|Merge sort uses which strategy?|Divide and conquer|Greedy|DP|Backtracking|0|Recursive splitting.
11|3|Which sort is non-comparison based?|Radix|Heap|Merge|Shell|0|Digit buckets.
12|4|Which data structure uses LIFO?|Stack|Queue|Graph|Array|0|Last in, first out.
13|3|Which is used to simulate recursion?|Stack|Queue|Tree|Hash table|0|Call frames.
14|3|Backtracking algorithm explores?|All possible states|Only sorted nodes|Only BFS|Only DFS|0|State-space.
15|4|Which issue occurs in naive recursion?|Stack overflow|Heap overflow|Queue underflow|Graph cycle|0|Deep calls.
16|4|Which uses FIFO?|Queue|Stack|Tree|Hash table|0|First in, first out.
17|3|Which queue supports insertion at rear, removal at front?|Simple queue|Deque|Circular array|Priority queue|0|Basic FIFO.
18|4|Which queue gives highest-priority removal first?|Priority queue|Circular queue|Double queue|Simple queue|0|Depends on priority.
19|4|Heaps implement which ADT?|Priority queue|Deque|Stack|BST|0|Efficient priority ops.
20|4|Heap property ensures?|Parent dominates children|Children dominate parent|Sorted array|Graph acyclic|0|Min/max organization.
21|4|Heap sort complexity?|O(n log n)|O(n²)|O(log n)|O(n)|0|Heapify + n removals.
22|4|BST search best case?|O(log n)|O(1)|O(n)|O(n log n)|0|Balanced depth.
23|5|Worst case BST becomes?|Linked list|Heap|AVL|Trie|0|Skewed on sorted input.
24|4|A complete binary tree has?|Filled left to right|Perfect leaves|Unbalanced nodes|Random filling|0|Level-wise fill.
25|5|Height of perfect binary tree?|log2(n+1) - 1|n|n log n|sqrt(n)|0|Full levels.
26|5|AVL trees maintain?|Height balance|Color balance|Degree limit|Sibling order|0|Rotations fix height.
27|5|Single rotation fixes which imbalance?|LL|LR|RL|RR|0|Straight left heavy.
28|5|Double rotation fixes?|LR or RL|LL only|RR only|LL/RR both|0|Z-shaped.
29|5|2-3 trees enforce?|All leaves same depth|Binary branching|Max 4 children|Fixed key count|0|Perfect height balance.
30|5|A B-tree node can have?|Multiple keys|Only one key|Only two keys|Only leaves|0|Multiway.
31|4|Hashing converts key to?|Index|Pointer|Node|Label|0|Direct address.
32|4|Collision resolution by chaining uses?|Linked lists|Arrays only|Stacks|Recursion|0|Buckets store lists.
33|4|Linear probing issue?|Primary clustering|Secondary memory|Heap corruption|DFS failure|0|Runs form.
34|5|Quadratic probing avoids?|Primary clustering|Hashing|Search|Rehash|0|Better spread.
35|4|Rehashing occurs when?|Load factor high|Key error|Tree full|Index sorted|0|Resize table.
36|5|KMP uses?|Prefix table|Suffix array|Hash|Boyer skip|0|LPS array.
37|5|Boyer-Moore uses?|Bad-character rule|Heap|Tree|Radix buckets|0|Skip ahead.
38|5|Rabin-Karp uses?|Rolling hash|Prefix tree|Graph|Stack|0|Fast substring checks.
39|4|Graphs consist of?|Vertices + edges|Nodes only|Edges only|Heaps|0|Basic structure.
40|4|Adjacency list is efficient for?|Sparse graphs|Dense graphs|Complete graphs|Binary trees|0|Few edges.
41|4|DFS uses?|Stack|Queue|Heap|Hash|0|Implicit/explicit stack.
42|4|BFS uses?|Queue|Stack|Tree|Linked list|0|Level-order.
43|5|Topological sort applies to?|DAG|Cyclic graph|Tree|Complete graph|0|Order by dependency.
44|5|Minimum spanning tree algorithm?|Kruskal|KMP|Boyer|Hoare|0|Greedy edges.
45|5|Prim’s algorithm uses?|Priority queue|Deque|Stack|List only|0|Grow tree.
46|5|Shortest path in weighted graph?|Dijkstra|DFS|BFS|Quick|0|Non-negative weights.
47|5|BST insertion is?|Recursive/iterative|Always O(1)|Non-deterministic|Randomized|0|Compare + descend.
48|3|Linked list stack push occurs at?|Head|Tail|Middle|Random|0|Fast insertion.
49|3|Queue based on LL removes from?|Head|Tail|Middle|None|0|Front removal.
50|4|Circular queue avoids?|Wasted space|Clustering|Tree imbalance|Hash collision|0|Wrap-around.
51|5|Merge sort space?|O(n)|O(1)|O(log n)|O(n²)|0|Extra array.
52|5|Quick worst case occurs on?|Sorted input (bad pivot)|Random input|Reverse hash|AVL|0|Pivot skew.
53|4|Shell sort improves on?|Insertion sort|Merge|BST|Hashing|0|Gapped comparison.
54|5|Radix sort needs?|Digits/buckets|Tree|Heap|Graph|0|Base-wise.
55|4|Safe arrays prevent?|Out-of-bound access|Hash collision|Heap overflow|AVL imbalance|0|Bounds checking.
56|5|Rule of Three includes?|Destructor|Copy ctor|Copy assignment|All 3|3|Memory safety.
57|3|Pass-by-reference allows?|Modify caller variable|Copy only|No access|Deep clone|0|Alias effect.
58|4|Binary tree max nodes at level h?|2^h|h|h²|log h|0|Level doubling.
59|4|Full binary tree property?|0 or 2 children|1 child only|More than 2 children|Arbitrary|0|No single-child nodes.
60|4|Complete binary tree property?|Filled left→right|Right→left full|Skew only|Random|0|Strict filling.
61|4|Height of complete tree approx?|log n|n|n log n|1|0|Near balanced.
62|4|Traversal root-left-right?|Preorder|Inorder|Postorder|Level|0|Prefix visit.
63|4|Traversal left-root-right?|Inorder|Preorder|Postorder|Level|0|Sorted for BST.
64|4|Traversal left-right-root?|Postorder|Preorder|Inorder|Level|0|Suffix visit.
65|4|Level order uses?|Queue|Stack|Hash|Tree|0|Breadth-first.
66|5|Height of AVL guaranteed?|O(log n)|O(n)|O(1)|O(n log n)|0|Balanced.
67|5|Heap represented using?|Array|LL only|Tree pointer|Trie|0|Index math.
68|4|Parent index in heap array?|(i-1)/2|2i|2i+1|i+1|0|Integer division.
69|4|Left child index?|2i+1|i+1|i-1|log i|0|Formula.
70|4|Right child index?|2i+2|i+2|i/2|3*i|0|Offset by 2.
71|4|Ideal hash load factor?|< 0.75|0.99|2|0.1|0|Balanced.
72|5|Rehash time cost?|O(n)|O(1)|O(log n)|O(n log n)|0|Reinsert all.
73|4|DFS detects cycles in?|Directed graphs|Heaps|Trees|Arrays|0|Back edges.
74|4|BFS finds shortest path in?|Unweighted graph|Weighted graph|Hash|Heap|0|Levels.
75|5|Dijkstra fails with?|Negative edges|Positive edges|Zero weights|Unweighted graph|0|Needs Bellman-Ford.
76|4|Adjacency matrix memory heavy for?|Dense graphs|Sparse graphs|Binary trees|Stacks|0|n² space.
77|4|Backtracking used in?|N-Queens|Bubble sort|Hashing|Prim|0|State search.
78|5|Pruning reduces?|Search states|Edges|Hash keys|Tree height|0|Efficiency.
79|4|Call stack stores?|Activation records|Graph edges|Heap nodes|Queue indices|0|Function context.
80|5|Tail recursion optimized by?|Compiler|Heap|Graph|Assembler|0|Stack elimination.
81|3|Queue overflow when?|Full|Empty|Front null|Rear null|0|No space left.
82|3|Stack underflow when?|Pop empty|Push full|Mid removed|Allocated|0|Empty pop.
83|5|Balanced search tree ensures?|Bounded height|Zero height|Hashing|Matrix|0|Log time.
84|5|B-tree used in?|Databases|Stacks|Graphs|Queues|0|Disk-friendly.
85|4|Hash function goal?|Uniform distribution|Sorted keys|Tree structure|Binary layout|0|Even spread.
86|5|Universal hashing avoids?|Predictable collisions|Heap errors|DFS cycles|Tree skew|0|Randomness.
87|4|Trie used for?|Prefix search|Sorting|Pathfinding|Compression|0|String dictionary.
88|5|BST removal requires?|Successor/predecessor|Queue|Hash|Merge|0|Replace node.
89|4|Skewed BST height?|O(n)|O(1)|O(log n)|O(n log n)|0|Linked-list-like.
90|5|Quick pivot choice affects?|Performance|Correctness|Hashing|Graph edges|0|Partition balance.
91|5|MST requires?|Connected graph|Directed graph|Negative cycles|No edges|0|Spanning possible.
92|5|Kruskal needs?|Sorting edges|Prefix table|Hash|Bitmask|0|Greedy.
93|4|Disjoint set used in?|Kruskal|KMP|Radix|Bubble|0|Cycle detection.
94|5|Path compression makes DSU?|Almost constant time|O(n)|O(log n)|Slow|0|Flattens tree.
95|4|Binary search requires?|Sorted data|Linked list|Graph|Hash|0|Mid-based.
96|4|Worst case linear search?|O(n)|O(1)|O(log n)|O(n log n)|0|Scan all.
97|4|Interpolation search fails on?|Uneven data|Sorted data|Even data|Hash|0|Requires uniform distribution.
98|3|DLL insertion before node requires updating?|4 pointers|1 pointer|None|2 pointers|0|Prev/next of two nodes.
99|4|Circular LL traversal ends when?|Back at head|Null found|Tail reached|Level up|0|Loop detected.
100|4|Array queue suffers?|False full|Infinite memory|Duplicate keys|Skew|0|Needs circular solution.
101|5|AVL rotation count worst case?|O(1)|O(n)|O(log n)|O(n log n)|0|Constant.
102|5|AVL height diff allowed?|≤1|≤2|≤3|Unlimited|0|Strict.
103|4|Heap insertion uses?|Percolate up|Percolate down|Hash|Rotate|0|Bubble up.
104|4|Heap deletion removes?|Root|Leaf|Middle|Child|0|Top priority.
105|5|Chaining worst search?|O(n)|O(1)|O(log n)|O(n log n)|0|All in one bucket.
106|4|Open addressing stores keys?|In array|In LL|Outside table|Tree|0|Probing.
107|4|Probe sequence must be?|Deterministic|Random|Sorted|Graph-like|0|Searchable.
108|5|Double hashing reduces?|Clustering|Tree height|Stack depth|Sort time|0|Better distribution.
109|4|DFS stack depth worst?|O(n)|O(1)|O(log n)|O(n log n)|0|Deep path.
110|5|Topological sort impossible if?|Cycle exists|Sparse|Dense|Small|0|Cycle breaks order.
111|4|Graph with edges < vertices?|Sparse|Dense|Complete|Tree|0|Low density.
112|4|Complete graph edges?|n(n-1)/2|n|log n|n²|0|All pairs.
113|5|DAG stands for?|Directed Acyclic Graph|Dual Adjacent Graph|Deep Array Graph|Degree Access Graph|0|No cycles.
114|3|Dynamic structure?|LL|Array|Matrix|Static table|0|Can grow.
115|4|Leaf node has?|0 children|1 child|2 children|3 children|0|Terminal.
116|5|BST inorder gives?|Sorted sequence|Reverse|Random|Level-wise|0|Monotonic.
117|5|Hash table worst case becomes?|Linked list|Tree|Heap|Graph|0|Collisions chain.
118|4|Array stack needs?|Top pointer|Front|Rear|Middle|0|Index.
119|4|LL queue needs?|Front+rear|Top|Left|Prev|0|Track both ends.
120|3|Unbounded logically?|LL queue|Array queue|Static tree|Matrix|0|Memory-dependent.
121|5|Quick average complexity?|O(n log n)|O(n)|O(n²)|O(log n)|0|Random pivot.
122|5|Count sort requires?|Small key range|Strings|Huge ranges|Tree nodes|0|Range-indexed.
123|4|Cycle detection uses?|DFS|BFS|Hash|Stack|0|Back edges.
124|5|Bellman-Ford handles?|Negative weights|Only positive|Only zero|Trees|0|Relax edges.
125|4|STL stack uses?|Deque|Tree|Graph|Set|0|Backed by deque.
126|4|STL priority_queue uses?|Max heap|Min heap|Trie|List|0|Binary heap.
127|5|2-3 tree insertion triggers?|Node split|Rotation|Hash|Merge|0|Overflow fix.
128|5|B-tree height vs BST?|Lower|Higher|Equal|Random|0|Wide nodes reduce height.
129|5|Trie tradeoff?|High memory|Low memory|No nodes|Pure hashing|0|Node per char.
130|4|RK collision handled by?|Verification|Skip|Hashing|Probe|0|Re-check substring.
131|5|Boyer Moore best for?|Long patterns|Short patterns|Numbers|Single char|0|Large skips.
132|4|KMP prefix table stores?|Longest border|Suffix|Prefix only|Hash|0|Overlap lengths.
133|5|Prim vs Kruskal difference?|Graph representation sensitivity|Identical performance|Not greedy|Hash usage|0|Dense vs sparse.
134|4|Traversal must mark?|Visited|Weight|Parent|Hash|0|Prevent loops.
135|4|Stack frame stores?|Local vars|Graph edges|Heap nodes|Queue indices|0|Activation.
136|5|Backtracking relies on?|Undo operations|Hash table|Matrix|Heap|0|State revert.
137|4|Height of binary tree?|Longest path to leaf|Shortest path|Node count|Edge count only|0|Definition.
138|5|AVL insertion worst case needs?|1 or 2 rotations|Many rotations|Hash|Tree rebuild|0|Guaranteed small fix.
139|4|Circular queue full when?|(rear+1)%n==front|front==rear|rear==0|front==0|0|Full condition.
140|5|Bottom-up heapify cost?|O(n)|O(log n)|O(n log n)|O(1)|0|Linear build.
141|5|Negative cycles make shortest path?|Undefined|Finite|Always zero|Always positive|0|Cost decreases forever.
142|4|SLL access by index?|O(n)|O(1)|O(log n)|O(n log n)|0|Sequential.
143|4|Array indexing?|O(1)|O(n)|O(n²)|O(log n)|0|Random access.
144|5|Treap balances using?|Random priority|Height|Color|Hash|0|Probabilistic.
145|5|RB-tree property?|No path >2x shorter|All paths equal|Only 1 rotation allowed|No leaves|0|Black-height rule.
146|5|RB trees guarantee?|O(log n)|O(1)|O(n)|O(n log n)|0|Balanced.
147|4|Graph diameter?|Longest shortest path|Deepest DFS|Max height|Any cycle|0|Farthest distance.
148|5|Floyd-Warshall solves?|All-pairs shortest path|Single-source|Longest path|Hash|0|DP matrix.
149|4|Deque supports?|Insert both ends|Only rear|Only front|Random|0|Double-ended.
150|5|Branch and bound differs by?|Using cost bounds|DFS only|BFS only|Hash only|0|Prune by cost